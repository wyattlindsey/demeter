'use strict';

// Load modules
/*istanbul ignore next*/var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;};
var Hoek = require('hoek');
var Topo = require('topo');
var Any = require('./any');
var Cast = require('./cast');


// Declare internals

var internals = {};


internals.Object = function () {

    Any.call(this);
    this._type = 'object';
    this._inner.children = null;
    this._inner.renames = [];
    this._inner.dependencies = [];
    this._inner.patterns = [];};


Hoek.inherits(internals.Object, Any);


internals.Object.prototype._base = function (value, state, options) {

    var target = value;
    var errors = [];
    var finish = function finish() {

        return { 
            value: target, 
            errors: errors.length ? errors : null };};



    if (typeof value === 'string' && 
    options.convert) {

        try {
            value = JSON.parse(value);} 

        catch (parseErr) {}}


    var type = this._flags.func ? 'function' : 'object';
    if (!value || 
    /*istanbul ignore next*/(typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== type || 
    Array.isArray(value)) {

        errors.push(this.createError(type + '.base', null, state, options));
        return finish();}


    // Skip if there are no other rules to test

    if (!this._inner.renames.length && 
    !this._inner.dependencies.length && 
    !this._inner.children && // null allows any keys
    !this._inner.patterns.length) {

        target = value;
        return finish();}


    // Ensure target is a local copy (parsed) or shallow copy

    if (target === value) {
        if (type === 'object') {
            target = Object.create(Object.getPrototypeOf(value));} else 

        {
            target = function /*istanbul ignore next*/target() {

                return value.apply(this, arguments);};


            target.prototype = Hoek.clone(value.prototype);}


        var valueKeys = Object.keys(value);
        for (var i = 0; i < valueKeys.length; ++i) {
            target[valueKeys[i]] = value[valueKeys[i]];}} else 


    {
        target = value;}


    // Rename keys

    var renamed = {};
    for (var _i = 0; _i < this._inner.renames.length; ++_i) {
        var item = this._inner.renames[_i];

        if (item.options.ignoreUndefined && target[item.from] === undefined) {
            continue;}


        if (!item.options.multiple && 
        renamed[item.to]) {

            errors.push(this.createError('object.rename.multiple', { from: item.from, to: item.to }, state, options));
            if (options.abortEarly) {
                return finish();}}



        if (Object.prototype.hasOwnProperty.call(target, item.to) && 
        !item.options.override && 
        !renamed[item.to]) {

            errors.push(this.createError('object.rename.override', { from: item.from, to: item.to }, state, options));
            if (options.abortEarly) {
                return finish();}}



        if (target[item.from] === undefined) {
            delete target[item.to];} else 

        {
            target[item.to] = target[item.from];}


        renamed[item.to] = true;

        if (!item.options.alias) {
            delete target[item.from];}}



    // Validate schema

    if (!this._inner.children && // null allows any keys
    !this._inner.patterns.length && 
    !this._inner.dependencies.length) {

        return finish();}


    var unprocessed = Hoek.mapToObject(Object.keys(target));

    // Children mustn't inherit the current label if it exists
    var childOptions = options.language && options.language.label ? 
    Hoek.applyToDefaults(options, { language: { label: null } }, true) : 
    options;

    if (this._inner.children) {
        for (var _i2 = 0; _i2 < this._inner.children.length; ++_i2) {
            var child = this._inner.children[_i2];
            var key = child.key;
            var _item = target[key];

            delete unprocessed[key];

            var localState = { key: key, path: (state.path || '') + (state.path && key ? '.' : '') + key, parent: target, reference: state.reference };
            var result = child.schema._validate(_item, localState, childOptions);
            if (result.errors) {
                errors.push(this.createError('object.child', { key: key, reason: result.errors }, localState, childOptions));

                if (options.abortEarly) {
                    return finish();}}



            if (child.schema._flags.strip || result.value === undefined && result.value !== _item) {
                delete target[key];} else 

            if (result.value !== undefined) {
                target[key] = result.value;}}}




    // Unknown keys

    var unprocessedKeys = Object.keys(unprocessed);
    if (unprocessedKeys.length && 
    this._inner.patterns.length) {

        for (var _i3 = 0; _i3 < unprocessedKeys.length; ++_i3) {
            var _key = unprocessedKeys[_i3];

            for (var j = 0; j < this._inner.patterns.length; ++j) {
                var pattern = this._inner.patterns[j];

                if (pattern.regex.test(_key)) {
                    delete unprocessed[_key];

                    var _item2 = target[_key];
                    var _localState = { key: _key, path: (state.path ? state.path + '.' : '') + _key, parent: target, reference: state.reference };
                    var _result = pattern.rule._validate(_item2, _localState, options);
                    if (_result.errors) {
                        errors.push(this.createError('object.child', { key: _key, reason: _result.errors }, _localState, options));

                        if (options.abortEarly) {
                            return finish();}}



                    if (_result.value !== undefined) {
                        target[_key] = _result.value;}}}}





        unprocessedKeys = Object.keys(unprocessed);}


    if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) {
        if (options.stripUnknown || 
        options.skipFunctions) {

            for (var _i4 = 0; _i4 < unprocessedKeys.length; ++_i4) {
                var _key2 = unprocessedKeys[_i4];

                if (options.stripUnknown) {
                    delete target[_key2];
                    delete unprocessed[_key2];} else 

                if (typeof target[_key2] === 'function') {
                    delete unprocessed[_key2];}}



            unprocessedKeys = Object.keys(unprocessed);}


        if (unprocessedKeys.length && (
        this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {

            for (var _i5 = 0; _i5 < unprocessedKeys.length; ++_i5) {
                errors.push(this.createError('object.allowUnknown', null, { key: unprocessedKeys[_i5], path: state.path + (state.path ? '.' : '') + unprocessedKeys[_i5] }, childOptions));}}}




    // Validate dependencies

    for (var _i6 = 0; _i6 < this._inner.dependencies.length; ++_i6) {
        var dep = this._inner.dependencies[_i6];
        var err = internals[dep.type].call(this, dep.key !== null && value[dep.key], dep.peers, target, { key: dep.key, path: (state.path || '') + (dep.key ? '.' + dep.key : '') }, options);
        if (err) {
            errors.push(err);
            if (options.abortEarly) {
                return finish();}}}




    return finish();};



internals.Object.prototype._func = function () {

    var obj = this.clone();
    obj._flags.func = true;
    return obj;};



internals.Object.prototype.keys = function (schema) {

    Hoek.assert(schema === null || schema === undefined || /*istanbul ignore next*/(typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) === 'object', 'Object schema must be a valid object');
    Hoek.assert(!schema || !schema.isJoi, 'Object schema cannot be a joi schema');

    var obj = this.clone();

    if (!schema) {
        obj._inner.children = null;
        return obj;}


    var children = Object.keys(schema);

    if (!children.length) {
        obj._inner.children = [];
        return obj;}


    var topo = new Topo();
    if (obj._inner.children) {
        for (var i = 0; i < obj._inner.children.length; ++i) {
            var child = obj._inner.children[i];

            // Only add the key if we are not going to replace it later
            if (children.indexOf(child.key) === -1) {
                topo.add(child, { after: child._refs, group: child.key });}}}




    for (var _i7 = 0; _i7 < children.length; ++_i7) {
        var key = children[_i7];
        var _child = schema[key];
        try {
            var cast = Cast.schema(_child);
            topo.add({ key: key, schema: cast }, { after: cast._refs, group: key });} 

        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.path = key + '.' + castErr.path;} else 

            {
                castErr.path = key;}

            throw castErr;}}



    obj._inner.children = topo.nodes;

    return obj;};



internals.Object.prototype.unknown = function (allow) {

    var obj = this.clone();
    obj._flags.allowUnknown = allow !== false;
    return obj;};



internals.Object.prototype.length = function (limit) {/*istanbul ignore next*/var _this = this;

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('length', limit, function (value, state, options) {

        if (Object.keys(value).length === limit) {
            return null;}


        return (/*istanbul ignore next*/_this.createError('object.length', { limit: limit }, state, options));});};



internals.Object.prototype.arity = function (n) {/*istanbul ignore next*/var _this2 = this;

    Hoek.assert(Hoek.isInteger(n) && n >= 0, 'n must be a positive integer');

    return this._test('arity', n, function (value, state, options) {

        if (value.length === n) {
            return null;}


        return (/*istanbul ignore next*/_this2.createError('function.arity', { n: n }, state, options));});};



internals.Object.prototype.minArity = function (n) {/*istanbul ignore next*/var _this3 = this;

    Hoek.assert(Hoek.isInteger(n) && n > 0, 'n must be a strict positive integer');

    return this._test('minArity', n, function (value, state, options) {

        if (value.length >= n) {
            return null;}


        return (/*istanbul ignore next*/_this3.createError('function.minArity', { n: n }, state, options));});};



internals.Object.prototype.maxArity = function (n) {/*istanbul ignore next*/var _this4 = this;

    Hoek.assert(Hoek.isInteger(n) && n >= 0, 'n must be a positive integer');

    return this._test('maxArity', n, function (value, state, options) {

        if (value.length <= n) {
            return null;}


        return (/*istanbul ignore next*/_this4.createError('function.maxArity', { n: n }, state, options));});};




internals.Object.prototype.min = function (limit) {/*istanbul ignore next*/var _this5 = this;

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('min', limit, function (value, state, options) {

        if (Object.keys(value).length >= limit) {
            return null;}


        return (/*istanbul ignore next*/_this5.createError('object.min', { limit: limit }, state, options));});};




internals.Object.prototype.max = function (limit) {/*istanbul ignore next*/var _this6 = this;

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('max', limit, function (value, state, options) {

        if (Object.keys(value).length <= limit) {
            return null;}


        return (/*istanbul ignore next*/_this6.createError('object.max', { limit: limit }, state, options));});};




internals.Object.prototype.pattern = function (pattern, schema) {

    Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');
    Hoek.assert(schema !== undefined, 'Invalid rule');

    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags

    try {
        schema = Cast.schema(schema);} 

    catch (castErr) {
        if (castErr.hasOwnProperty('path')) {
            castErr.message = castErr.message + '(' + castErr.path + ')';}


        throw castErr;}



    var obj = this.clone();
    obj._inner.patterns.push({ regex: pattern, rule: schema });
    return obj;};



internals.Object.prototype.with = function (key, peers) {

    return this._dependency('with', key, peers);};



internals.Object.prototype.without = function (key, peers) {

    return this._dependency('without', key, peers);};



internals.Object.prototype.xor = function () {

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('xor', null, peers);};



internals.Object.prototype.or = function () {

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('or', null, peers);};



internals.Object.prototype.and = function () {

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('and', null, peers);};



internals.Object.prototype.nand = function () {

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('nand', null, peers);};



internals.Object.prototype.requiredKeys = function (children) {

    children = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this.applyFunctionToChildren(children, 'required');};



internals.Object.prototype.optionalKeys = function (children) {

    children = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this.applyFunctionToChildren(children, 'optional');};



internals.renameDefaults = { 
    alias: false, // Keep old value in place
    multiple: false, // Allow renaming multiple keys into the same target
    override: false // Overrides an existing key
};


internals.Object.prototype.rename = function (from, to, options) {

    Hoek.assert(typeof from === 'string', 'Rename missing the from argument');
    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);

    for (var i = 0; i < this._inner.renames.length; ++i) {
        Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');}


    var obj = this.clone();

    obj._inner.renames.push({ 
        from: from, 
        to: to, 
        options: Hoek.applyToDefaults(internals.renameDefaults, options || {}) });


    return obj;};



internals.groupChildren = function (children) {

    children.sort();

    var grouped = {};

    for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        Hoek.assert(typeof child === 'string', 'children must be strings');
        var group = child.split('.')[0];
        var childGroup = grouped[group] = grouped[group] || [];
        childGroup.push(child.substring(group.length + 1));}


    return grouped;};



internals.Object.prototype.applyFunctionToChildren = function (children, fn, args, root) {

    children = [].concat(children);
    Hoek.assert(children.length > 0, 'expected at least one children');

    var groupedChildren = internals.groupChildren(children);
    var obj = /*istanbul ignore next*/void 0;

    if ('' in groupedChildren) {
        obj = this[fn].apply(this, args);
        delete groupedChildren[''];} else 

    {
        obj = this.clone();}


    if (obj._inner.children) {
        root = root ? root + '.' : '';

        for (var i = 0; i < obj._inner.children.length; ++i) {
            var child = obj._inner.children[i];
            var group = groupedChildren[child.key];

            if (group) {
                obj._inner.children[i] = { 
                    key: child.key, 
                    _refs: child._refs, 
                    schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key) };


                delete groupedChildren[child.key];}}}




    var remaining = Object.keys(groupedChildren);
    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));

    return obj;};



internals.Object.prototype._dependency = function (type, key, peers) {

    peers = [].concat(peers);
    for (var i = 0; i < peers.length; ++i) {
        Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');}


    var obj = this.clone();
    obj._inner.dependencies.push({ type: type, key: key, peers: peers });
    return obj;};



internals.with = function (value, peers, parent, state, options) {

    if (value === undefined) {
        return null;}


    for (var i = 0; i < peers.length; ++i) {
        var peer = peers[i];
        if (!Object.prototype.hasOwnProperty.call(parent, peer) || 
        parent[peer] === undefined) {

            return this.createError('object.with', { peer: peer }, state, options);}}



    return null;};



internals.without = function (value, peers, parent, state, options) {

    if (value === undefined) {
        return null;}


    for (var i = 0; i < peers.length; ++i) {
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) && 
        parent[peer] !== undefined) {

            return this.createError('object.without', { peer: peer }, state, options);}}



    return null;};



internals.xor = function (value, peers, parent, state, options) {

    var present = [];
    for (var i = 0; i < peers.length; ++i) {
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) && 
        parent[peer] !== undefined) {

            present.push(peer);}}



    if (present.length === 1) {
        return null;}


    if (present.length === 0) {
        return this.createError('object.missing', { peers: peers }, state, options);}


    return this.createError('object.xor', { peers: peers }, state, options);};



internals.or = function (value, peers, parent, state, options) {

    for (var i = 0; i < peers.length; ++i) {
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) && 
        parent[peer] !== undefined) {
            return null;}}



    return this.createError('object.missing', { peers: peers }, state, options);};



internals.and = function (value, peers, parent, state, options) {

    var missing = [];
    var present = [];
    var count = peers.length;
    for (var i = 0; i < count; ++i) {
        var peer = peers[i];
        if (!Object.prototype.hasOwnProperty.call(parent, peer) || 
        parent[peer] === undefined) {

            missing.push(peer);} else 

        {
            present.push(peer);}}



    var aon = missing.length === count || present.length === count;
    return !aon ? this.createError('object.and', { present: present, missing: missing }, state, options) : null;};



internals.nand = function (value, peers, parent, state, options) {

    var present = [];
    for (var i = 0; i < peers.length; ++i) {
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) && 
        parent[peer] !== undefined) {

            present.push(peer);}}



    var values = Hoek.clone(peers);
    var main = values.splice(0, 1)[0];
    var allPresent = present.length === peers.length;
    return allPresent ? this.createError('object.nand', { main: main, peers: values }, state, options) : null;};



internals.Object.prototype.describe = function (shallow) {

    var description = Any.prototype.describe.call(this);

    if (description.rules) {
        for (var i = 0; i < description.rules.length; ++i) {
            var rule = description.rules[i];
            // Coverage off for future-proof descriptions, only object().assert() is use right now
            if ( /* $lab:coverage:off$ */rule.arg && 
            /*istanbul ignore next*/_typeof(rule.arg) === 'object' && 
            rule.arg.schema && 
            rule.arg.ref /* $lab:coverage:on$ */) {
                    rule.arg = { 
                        schema: rule.arg.schema.describe(), 
                        ref: rule.arg.ref.toString() };}}}





    if (this._inner.children && 
    !shallow) {

        description.children = {};
        for (var _i8 = 0; _i8 < this._inner.children.length; ++_i8) {
            var child = this._inner.children[_i8];
            description.children[child.key] = child.schema.describe();}}



    if (this._inner.dependencies.length) {
        description.dependencies = Hoek.clone(this._inner.dependencies);}


    if (this._inner.patterns.length) {
        description.patterns = [];

        for (var _i9 = 0; _i9 < this._inner.patterns.length; ++_i9) {
            var pattern = this._inner.patterns[_i9];
            description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });}}



    return description;};



internals.Object.prototype.assert = function (ref, schema, message) {/*istanbul ignore next*/var _this7 = this;

    ref = Cast.ref(ref);
    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
    message = message || 'pass the assertion test';

    try {
        schema = Cast.schema(schema);} 

    catch (castErr) {
        if (castErr.hasOwnProperty('path')) {
            castErr.message = castErr.message + '(' + castErr.path + ')';}


        throw castErr;}


    var key = ref.path[ref.path.length - 1];
    var path = ref.path.join('.');

    return this._test('assert', { schema: schema, ref: ref }, function (value, state, options) {

        var result = schema._validate(ref(value), null, options, value);
        if (!result.errors) {
            return null;}


        var localState = Hoek.merge({}, state);
        localState.key = key;
        localState.path = path;
        return (/*istanbul ignore next*/_this7.createError('object.assert', { ref: localState.path, message: message }, localState, options));});};




internals.Object.prototype.type = function (constructor, name) {/*istanbul ignore next*/var _this8 = this;

    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
    name = name || constructor.name;

    return this._test('type', name, function (value, state, options) {

        if (value instanceof constructor) {
            return null;}


        return (/*istanbul ignore next*/_this8.createError('object.type', { type: name }, state, options));});};




module.exports = new internals.Object();