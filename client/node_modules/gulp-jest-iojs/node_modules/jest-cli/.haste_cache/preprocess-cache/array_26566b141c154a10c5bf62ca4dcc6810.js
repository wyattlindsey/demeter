'use strict';

// Load modules
/*istanbul ignore next*/var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;};
var Any = require('./any');
var Cast = require('./cast');
var Hoek = require('hoek');


// Declare internals

var internals = {};


internals.fastSplice = function (arr, i) {

    var pos = i;
    while (pos < arr.length) {
        arr[pos++] = arr[pos];}


    --arr.length;};



internals.Array = function () {

    Any.call(this);
    this._type = 'array';
    this._inner.items = [];
    this._inner.ordereds = [];
    this._inner.inclusions = [];
    this._inner.exclusions = [];
    this._inner.requireds = [];
    this._flags.sparse = false;};


Hoek.inherits(internals.Array, Any);


internals.Array.prototype._base = function (value, state, options) {

    var result = { 
        value: value };


    if (typeof value === 'string' && 
    options.convert) {

        try {
            var converted = JSON.parse(value);
            if (Array.isArray(converted)) {
                result.value = converted;}} 


        catch (e) {}}


    var isArray = Array.isArray(result.value);
    var wasArray = isArray;
    if (options.convert && this._flags.single && !isArray) {
        result.value = [result.value];
        isArray = true;}


    if (!isArray) {
        result.errors = this.createError('array.base', null, state, options);
        return result;}


    if (this._inner.inclusions.length || 
    this._inner.exclusions.length || 
    !this._flags.sparse) {

        // Clone the array so that we don't modify the original
        if (wasArray) {
            result.value = result.value.slice(0);}


        result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);

        if (result.errors && wasArray && options.convert && this._flags.single) {

            // Attempt a 2nd pass by putting the array inside one.
            var previousErrors = result.errors;

            result.value = [result.value];
            result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);

            if (result.errors) {

                // Restore previous errors and value since this didn't validate either.
                result.errors = previousErrors;
                result.value = result.value[0];}}}




    return result;};



internals.checkItems = function (items, wasArray, state, options) {

    var errors = [];
    var errored = /*istanbul ignore next*/void 0;

    var requireds = this._inner.requireds.slice();
    var ordereds = this._inner.ordereds.slice();
    var inclusions = this._inner.inclusions.concat(requireds);

    var il = items.length;
    for (var i = 0; i < il; ++i) {
        errored = false;
        var item = items[i];
        var isValid = false;
        var key = wasArray ? i : state.key;
        var path = wasArray ? (state.path ? state.path + '.' : '') + i : state.path;
        var localState = { key: key, path: path, parent: items, reference: state.reference };
        var res = /*istanbul ignore next*/void 0;

        // Sparse

        if (!this._flags.sparse && item === undefined) {
            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path }, options));

            if (options.abortEarly) {
                return errors;}


            continue;}


        // Exclusions

        for (var j = 0; j < this._inner.exclusions.length; ++j) {
            res = this._inner.exclusions[j]._validate(item, localState, {}); // Not passing options to use defaults

            if (!res.errors) {
                errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));
                errored = true;

                if (options.abortEarly) {
                    return errors;}


                break;}}



        if (errored) {
            continue;}


        // Ordered
        if (this._inner.ordereds.length) {
            if (ordereds.length > 0) {
                var ordered = ordereds.shift();
                res = ordered._validate(item, localState, options);
                if (!res.errors) {
                    if (ordered._flags.strip) {
                        internals.fastSplice(items, i);
                        --i;
                        --il;} else 

                    {
                        items[i] = res.value;}} else 


                {
                    errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                    if (options.abortEarly) {
                        return errors;}}


                continue;} else 

            if (!this._inner.items.length) {
                errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));
                if (options.abortEarly) {
                    return errors;}

                continue;}}



        // Requireds

        var requiredChecks = [];
        var jl = requireds.length;
        for (var _j = 0; _j < jl; ++_j) {
            res = requiredChecks[_j] = requireds[_j]._validate(item, localState, options);
            if (!res.errors) {
                items[i] = res.value;
                isValid = true;
                internals.fastSplice(requireds, _j);
                --_j;
                --jl;
                break;}}



        if (isValid) {
            continue;}


        // Inclusions

        jl = inclusions.length;
        for (var _j2 = 0; _j2 < jl; ++_j2) {
            var inclusion = inclusions[_j2];

            // Avoid re-running requireds that already didn't match in the previous loop
            var previousCheck = requireds.indexOf(inclusion);
            if (previousCheck !== -1) {
                res = requiredChecks[previousCheck];} else 

            {
                res = inclusion._validate(item, localState, options);

                if (!res.errors) {
                    if (inclusion._flags.strip) {
                        internals.fastSplice(items, i);
                        --i;
                        --il;} else 

                    {
                        items[i] = res.value;}

                    isValid = true;
                    break;}}



            // Return the actual error if only one inclusion defined
            if (jl === 1) {
                if (options.stripUnknown) {
                    internals.fastSplice(items, i);
                    --i;
                    --il;
                    isValid = true;
                    break;}


                errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                errored = true;

                if (options.abortEarly) {
                    return errors;}


                break;}}



        if (errored) {
            continue;}


        if (this._inner.inclusions.length && !isValid) {
            if (options.stripUnknown) {
                internals.fastSplice(items, i);
                --i;
                --il;
                continue;}


            errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));

            if (options.abortEarly) {
                return errors;}}}




    if (requireds.length) {
        internals.fillMissedErrors.call(this, errors, requireds, state, options);}


    if (ordereds.length) {
        internals.fillOrderedErrors.call(this, errors, ordereds, state, options);}


    return errors.length ? errors : null;};



internals.fillMissedErrors = function (errors, requireds, state, options) {

    var knownMisses = [];
    var unknownMisses = 0;
    for (var i = 0; i < requireds.length; ++i) {
        var label = Hoek.reach(requireds[i], '_settings.language.label');
        if (label) {
            knownMisses.push(label);} else 

        {
            ++unknownMisses;}}



    if (knownMisses.length) {
        if (unknownMisses) {
            errors.push(this.createError('array.includesRequiredBoth', { knownMisses: knownMisses, unknownMisses: unknownMisses }, { key: state.key, path: state.patk }, options));} else 

        {
            errors.push(this.createError('array.includesRequiredKnowns', { knownMisses: knownMisses }, { key: state.key, path: state.path }, options));}} else 


    {
        errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses: unknownMisses }, { key: state.key, path: state.path }, options));}};




internals.fillOrderedErrors = function (errors, ordereds, state, options) {

    var requiredOrdereds = [];

    for (var i = 0; i < ordereds.length; ++i) {
        var presence = Hoek.reach(ordereds[i], '_flags.presence');
        if (presence === 'required') {
            requiredOrdereds.push(ordereds[i]);}}



    if (requiredOrdereds.length) {
        internals.fillMissedErrors.call(this, errors, requiredOrdereds, state, options);}};



internals.Array.prototype.describe = function () {

    var description = Any.prototype.describe.call(this);

    if (this._inner.ordereds.length) {
        description.orderedItems = [];

        for (var i = 0; i < this._inner.ordereds.length; ++i) {
            description.orderedItems.push(this._inner.ordereds[i].describe());}}



    if (this._inner.items.length) {
        description.items = [];

        for (var _i = 0; _i < this._inner.items.length; ++_i) {
            description.items.push(this._inner.items[_i].describe());}}



    return description;};



internals.Array.prototype.items = function () {

    var obj = this.clone();

    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) {

        try {
            type = Cast.schema(type);} 

        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.path = index + '.' + castErr.path;} else 

            {
                castErr.path = index;}

            castErr.message = castErr.message + '(' + castErr.path + ')';
            throw castErr;}


        obj._inner.items.push(type);

        if (type._flags.presence === 'required') {
            obj._inner.requireds.push(type);} else 

        if (type._flags.presence === 'forbidden') {
            obj._inner.exclusions.push(type.optional());} else 

        {
            obj._inner.inclusions.push(type);}});



    return obj;};



internals.Array.prototype.ordered = function () {

    var obj = this.clone();

    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) {

        try {
            type = Cast.schema(type);} 

        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.path = index + '.' + castErr.path;} else 

            {
                castErr.path = index;}

            castErr.message = castErr.message + '(' + castErr.path + ')';
            throw castErr;}

        obj._inner.ordereds.push(type);});


    return obj;};



internals.Array.prototype.min = function (limit) {/*istanbul ignore next*/var _this = this;

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('min', limit, function (value, state, options) {

        if (value.length >= limit) {
            return null;}


        return (/*istanbul ignore next*/_this.createError('array.min', { limit: limit, value: value }, state, options));});};




internals.Array.prototype.max = function (limit) {/*istanbul ignore next*/var _this2 = this;

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('max', limit, function (value, state, options) {

        if (value.length <= limit) {
            return null;}


        return (/*istanbul ignore next*/_this2.createError('array.max', { limit: limit, value: value }, state, options));});};




internals.Array.prototype.length = function (limit) {/*istanbul ignore next*/var _this3 = this;

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('length', limit, function (value, state, options) {

        if (value.length === limit) {
            return null;}


        return (/*istanbul ignore next*/_this3.createError('array.length', { limit: limit, value: value }, state, options));});};




internals.Array.prototype.unique = function () {/*istanbul ignore next*/var _this4 = this;

    return this._test('unique', undefined, function (value, state, options) {

        var found = { 
            string: {}, 
            number: {}, 
            undefined: {}, 
            boolean: {}, 
            object: [], 
            function: [] };


        for (var i = 0; i < value.length; ++i) {
            var item = value[i];
            var type = /*istanbul ignore next*/typeof item === 'undefined' ? 'undefined' : _typeof(item);
            var records = found[type];

            // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.
            // I still want to keep the test for future js versions with new types (eg. Symbol).
            if ( /* $lab:coverage:off$ */records /* $lab:coverage:on$ */) {
                    if (Array.isArray(records)) {
                        for (var j = 0; j < records.length; ++j) {
                            if (Hoek.deepEqual(records[j], item)) {
                                return (/*istanbul ignore next*/_this4.createError('array.unique', { pos: i, value: item }, state, options));}}



                        records.push(item);} else 

                    {
                        if (records[item]) {
                            return (/*istanbul ignore next*/_this4.createError('array.unique', { pos: i, value: item }, state, options));}


                        records[item] = true;}}}




        return null;});};




internals.Array.prototype.sparse = function (enabled) {

    var obj = this.clone();
    obj._flags.sparse = enabled === undefined ? true : !!enabled;
    return obj;};



internals.Array.prototype.single = function (enabled) {

    var obj = this.clone();
    obj._flags.single = enabled === undefined ? true : !!enabled;
    return obj;};



module.exports = new internals.Array();