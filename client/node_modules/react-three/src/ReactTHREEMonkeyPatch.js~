//
// time to monkey-patch React!
//
// a subtle bug happens when ReactCompositeComponent updates something in-place by
// modifying HTML markup; since THREE objects don't exist as markup the whole thing bombs.
// we try to fix this by monkey-patching ReactCompositeComponent
//

"use strict";

var ReactCompositeComponent = require('react/lib/ReactCompositeComponent');
var ReactCompositeComponentMixin = ReactCompositeComponent.Mixin;
var ReactReconciler = require('react/lib/ReactReconciler');

var ReactNativeComponent = require('react/lib/ReactNativeComponent');
var shouldUpdateReactComponent = require('react/lib/shouldUpdateReactComponent');
var warning = require('react/lib/warning');
var invariant = require('react/lib/invariant');


//
// Composite components don't have a displayObject. So we have to do some work to find
// the proper Object3D sometimes.
//

function findObject3DAncestor(componentinstance) {
  // walk up via _owner until we find something with a displayObject hasOwnProperty
  var componentwalker = componentinstance._currentElement._owner;
  while (typeof componentwalker !== 'undefined') {
    // no owner? then fail
    if (typeof componentwalker._renderedComponent._THREEObject3D !== 'undefined') {
      return componentwalker._renderedComponent._THREEObject3D;
    }
    componentwalker = componentwalker._currentElement._owner;
  }

  // we walked all the way up and found no Object3D
  return undefined;
}

function findObject3DChild(componentinstance) {
  // walk downwards via _renderedComponent to find something with a displayObject
  var componentwalker = componentinstance;
  while (typeof componentwalker !== 'undefined') {
    // no displayObject? then fail
    if (typeof componentwalker._THREEObject3D !== 'undefined') {
      return componentwalker._THREEObject3D;
    }
    componentwalker = componentwalker._renderedComponent;
  }

  // we walked all the way down and found no Object3D
  return undefined;

}

//
// We only want to patch composite components, so we use this
// function to determine which elements are composite components.
//

function isCompositeComponentType(element) {
  return (element !== null &&
	  typeof element === 'object' &&
	  typeof element.type === 'function' &&
	  typeof element.type.prototype.mountComponent !== 'function');
}

//
// This modified version of updateRenderedComponent will
// manage Object3D nodes instead of HTML markup
//

var ReactTHREE_updateRenderedComponent = function(transaction, context) {
  var prevComponentInstance = this._renderedComponent;
  
  // Find the first actual rendered (non-Composite) component.
  // If that component is a THREE node we use the special code here.
  // If not, we call back to the original version of updateComponent
  // which should handle all non-THREE nodes.
  
  var prevObject3D = findObject3DChild(prevComponentInstance);
  if (!prevObject3D) {
    // not a THREE node, use the original DOM-style version
    old_updateRenderedComponent.call(this,transaction, context);
    return;
  }
  
  // This is a THREE node, do a special THREE version of updateComponent
  var prevRenderedElement = prevComponentInstance._currentElement;
  var nextRenderedElement = this._renderValidatedComponent();
  
  if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
    ReactReconciler.receiveComponent(
      prevComponentInstance,
      nextRenderedElement,
      transaction,
      this._processChildContext(context)
    );
  } else {
    // We can't just update the current component.
    // So we nuke the current instantiated component and put a new component in
    // the same place based on the new props.
    var nodeID = this._reactInternalInstance._rootNodeID;
    
    var object3DParent = prevObject3D.parent;
    
    // validate that the findObject3DAncestor finds the same parent
    // as simply getting the 'parent' member. If these differ than the
    // code in this function needs to be rewritten
    if ("production" !== process.env.NODE_ENV) { // jshint ignore:line
      // this should produce the parent as well
      var object3DAncestor = findObject3DAncestor(this);
      invariant(object3DAncestor === object3DParent,
		'Object3D found by following _owner fields should match Object3D parent');
    }
    
    // unmounting doesn't disconnect the child from the parent node,
    // but later on we'll simply overwrite the proper element in the 'children' data member
    var object3DIndex = object3DParent.children.indexOf(prevObject3D);
    ReactReconciler.unmountComponent(prevComponentInstance);
    this._THREEObject3D = null;
    
    // create the new object and stuff it into the place vacated by the old object
    this._renderedComponent = this._instantiateReactComponent(
      nextRenderedElement,
      this._currentElement.type);
    var nextObject3D = ReactReconciler.mountComponent(
      this._renderedComponent,
      nodeID,
      transaction,
      context
    );
    this._THREEObject3D = nextObject3D;
    
    // fixup _mountImage as well
    this._mountImage = this._THREEObject3D;
    
    // overwrite the old child
    object3DParent.children[object3DIndex] = nextObject3D;
  }
};


var ReactTHREEMonkeyPatch = function() {
  
  var old_instantiateReactComponent = ReactCompositeComponentMixin._updateRenderedComponent;

  // check to see if we already patched it, so we don't patch it again
  if (typeof old_instantiateReactComponent._ReactTHREEPatched === 'undefined') {
    console.log("patching react for react-three");

    old_instantiateReactComponent._ReactTHREEPatched = true;
    instantiateReactComponent
  }
};

module.exports = ReactTHREEMonkeyPatch;

